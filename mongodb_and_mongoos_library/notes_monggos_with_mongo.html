<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <ul>
      <li><h1>ğŸ”¥ LETâ€™S START â€“ PHASE 0ï¸âƒ£</h1></li>
      <ul>
        <li>
          <pre>
<h3>1ï¸âƒ£ What is a Database? (Very Simple)</h3>
A database is a place to store data permanently.

ğŸ“Œ Example:

Users

Products

Orders

Without database â†’ data is lost when server restarts âŒ

<h3>
  2ï¸âƒ£ What is NoSQL?
</h3>
NoSQL means:

No fixed table structure

Flexible data

Stores data as documents

ğŸ“„ Example document:

{
  "name": "Bhavesh",
  "age": 22,
  "skills": ["JS", "Node"]
}


<h3>3ï¸âƒ£ What is MongoDB?</h3>
MongoDB is a NoSQL database

Stores data in:

Database

Collection

Document

ğŸ“¦ Structure:

Database
 â””â”€â”€ Collection
      â””â”€â”€ Document

<h3>4ï¸âƒ£ MongoDB vs SQL (Simple Table)</h3>
| SQL          | MongoDB         |
| ------------ | --------------- |
| Tables       | Collections     |
| Rows         | Documents       |
| Columns      | Fields          |
| Fixed schema | Flexible schema |


<h3>5ï¸âƒ£ What is Mongoose?</h3>
Mongoose is an ODM (Object Data Modeling)

Helps Node.js talk to MongoDB

Adds:
âœ” Schema
âœ” Validation
âœ” Clean syntax

ğŸ“Œ MongoDB alone = raw
ğŸ“Œ MongoDB + Mongoose = professional



          </pre>
        </li>
      </ul>
      <li><h1>ğŸš€ PHASE 1ï¸âƒ£ â€“ SETUP</h1></li>
      <ul>
        <li>
          <pre>
<h3>6ï¸âƒ£ Install MongoDB</h3>
Option A (Recommended)

Install MongoDB Community Server

Install MongoDB Compass

ğŸ‘‰ Iâ€™ll assume local MongoDB

<h3>7ï¸âƒ£ Create Project</h3>
mkdir mongo-course
cd mongo-course
npm init -y
npm install express mongoose


<h3>8ï¸âƒ£ Basic Server (app.js)</h3>
const express = require("express");
const mongoose = require("mongoose");

const app = express();
app.use(express.json());

mongoose.connect("mongodb://127.0.0.1:27017/mongoCourse")
  .then(() => console.log("MongoDB Connected"))
  .catch(err => console.log(err));

app.listen(3000, () => {
  console.log("Server running on port 3000");
});


âœ… If you see MongoDB Connected â†’ perfect




        </pre>
        </li>
      </ul>
      <li><h1>ğŸ”¥ PHASE 2ï¸âƒ£ â€“ CORE MONGOOSE (VERY IMPORTANT)</h1></li>
      <ul>
        <li>
          <pre>
<h3>9ï¸âƒ£ Schema (Blueprint)</h3>
const mongoose = require("mongoose");

const userSchema = new mongoose.Schema({
  name: String,
  age: Number,
  email: String
});


ğŸ‘‰ Schema defines structure

<h3>ğŸ”Ÿ Model (Controller)</h3>
const User = mongoose.model("User", userSchema);

ğŸ‘‰ Model is used to CRUD data

<h3>1ï¸âƒ£1ï¸âƒ£ Create (INSERT)</h3>
app.post("/add-user", async (req, res) => {
  const user = new User({
    name: "Bhavesh",
    age: 22,
    email: "b@gmail.com"
  });

  await user.save();
  res.send("User saved");
});


<h3>1ï¸âƒ£2ï¸âƒ£ Read (GET)</h3>
app.get("/users", async (req, res) => {
  const users = await User.find();
  res.json(users);
});


<h3>1ï¸âƒ£3ï¸âƒ£ Update</h3>
app.put("/user/:id", async (req, res) => {
  await User.findByIdAndUpdate(req.params.id, { age: 25 });
  res.send("Updated");
});


<h3>1ï¸âƒ£4ï¸âƒ£ Delete</h3>
app.delete("/user/:id", async (req, res) => {
  await User.findByIdAndDelete(req.params.id);
  res.send("Deleted");
});




        </pre>
        </li>
      </ul>
      <li>
        <h1>ğŸ”¥ PHASE 3ï¸âƒ£ â€“ MONGOOSE SCHEMA & VALIDATION (VERY IMPORTANT)</h1>
      </li>
      <ul>
        <li>
          <pre>
This phase is mandatory for interviews & real projects.
<h3>1ï¸âƒ£ Why Validation is IMPORTANT?</h3>

Without validation:

Empty data can be saved âŒ

Wrong data type can be saved âŒ

Duplicate email allowed âŒ

With validation:

Clean data âœ…

Less bugs âœ…

Professional code âœ…

<h2>ğŸ§  SCHEMA IN DEPTH</h2>
<h3>2ï¸âƒ£ Basic Schema with Types</h3>
const mongoose = require("mongoose");

const userSchema = new mongoose.Schema({
  name: String,
  age: Number,
  email: String
});


<h3>3ï¸âƒ£ Required Field</h3>
const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true
  },
  age: Number
});


âŒ Without name â†’ error
âœ… With name â†’ saved

<h3>4ï¸âƒ£ Default Value</h3>
isActive: {
  type: Boolean,
  default: true
}


If not provided â†’ MongoDB sets it automatically

<h3>5ï¸âƒ£ Min & Max (Number)</h3>
age: {
  type: Number,
  min: 18,
  max: 60
}


<h3>6ï¸âƒ£ String Validation</h3>
name: {
  type: String,
  minlength: 3,
  maxlength: 20
}


<h3>7ï¸âƒ£ Unique Field (VERY COMMON)</h3>
email: {
  type: String,
  required: true,
  unique: true
}

âš ï¸ unique creates index, not validation
But works fine for beginners

<h3>8ï¸âƒ£ Full Professional Schema</h3>
const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    minlength: 3
  },
  age: {
    type: Number,
    min: 18,
    max: 60
  },
  email: {
    type: String,
    required: true,
    unique: true
  },
  isActive: {
    type: Boolean,
    default: true
  }
});





      </pre>
        </li>
      </ul>
      <li><h1>ğŸ”¥ ERROR HANDLING (IMPORTANT)</h1></li>
      <ul>
        <li>
          <pre>
<h3>9ï¸âƒ£ Tryâ€“Catch (MUST)</h3>
app.post("/add-user", async (req, res) => {
  try {
    const user = await User.create(req.body);
    res.json(user);
  } catch (error) {
    res.status(400).json({
      message: error.message
    });
  }
});

<h3>ğŸ” Example Errors</h3>
| Problem         | Error                   |
| --------------- | ----------------------- |
| Missing name    | Path `name` is required |
| Duplicate email | E11000 duplicate key    |
| Age < 18        | Validator failed        |


      </pre>
        </li>
      </ul>
      <li><h1>ğŸ”¥ PHASE 4ï¸âƒ£ â€“ MONGOOSE QUERIES</h1></li>
      <ul>
        <li>
          <pre>
Assume this User Schema:
{
  name: "Bhavesh",
  age: 22,
  email: "b@gmail.com",
  isActive: true
}

<h3>1ï¸âƒ£ find() â€“ Get ALL matching documents</h3>
const users = await User.find();
ğŸ“Œ Returns array

<h3>2ï¸âƒ£ findOne() â€“ Get ONE document</h3>
const user = await User.findOne({ email: "b@gmail.com" });

ğŸ“Œ Returns single object

<h3>3ï¸âƒ£ findById()</h3>
const user = await User.findById("64f8...");

ğŸ“Œ Best when using _id

<h2>ğŸ” FILTERING DATA</h2>
<h3>4ï¸âƒ£ Simple Filter</h3>
User.find({ age: 22 });

<h3>5ï¸âƒ£ Comparison Operators</h3>
| Operator | Meaning      |
| -------- | ------------ |
| `$gt`    | greater than |
| `$lt`    | less than    |
| `$gte`   | &gt;=           |
| `$lte`   | &lt;=           |


User.find({ age: { $gte: 18, $lte: 25 } });


<h3>6ï¸âƒ£ Logical Operators</h3>
<h4>AND (default)</h4>
User.find({ age: 22, isActive: true });

<h4>OR</h4>
User.find({
  $or: [
    { age: 22 },
    { isActive: false }
  ]
});

<h2>ğŸ”ƒ SORTING</h2>
<h3>7ï¸âƒ£ Sort Data</h3>
User.find().sort({ age: 1 });   // ascending
User.find().sort({ age: -1 });  // descending


<h2>ğŸ“„ LIMIT & PAGINATION (VERY IMPORTANT)</h2>
<h3>8ï¸âƒ£ Limit</h3>
User.find().limit(5);


<h3>9ï¸âƒ£ Pagination (REAL WORLD)</h3>
const page = 2;
const limit = 3;

User.find()
  .skip((page - 1) * limit)
  .limit(limit);


  <h2>ğŸ” SEARCH (TEXT SEARCH)</h2>
  <h3>ğŸ”Ÿ Regex Search (Beginner Friendly)</h3>
  User.find({
  name: { $regex: "bha", $options: "i" }
});

ğŸ“Œ Finds:

Bhavesh

bhavin

Abhay

<h2>ğŸ¯ SELECT (SHOW ONLY REQUIRED FIELDS)</h2>
User.find().select("name email");
âŒ hides other fields

<h2>ğŸ§ª COMPLETE API EXAMPLE</h2>
app.get("/users", async (req, res) => {
  const users = await User.find({ isActive: true })
    .sort({ age: -1 })
    .limit(5)
    .select("name age");

  res.json(users);
});



        </pre>
        </li>
      </ul>
      <li><h1>ğŸ”¥ PHASE 5ï¸âƒ£ â€“ RELATIONSHIPS & populate()</h1></li>
      <ul>
        <li>
          <pre>
MongoDB is NoSQL, but we still create relationships using ObjectId references.

<h2>ğŸ§  Types of Relationships</h2>
1. One-to-One

2. One-to-Many

3. Many-to-Many

Weâ€™ll cover all.


<h3>1ï¸âƒ£ ONE-TO-ONE</h3>
Example:
            One User â†’ One Profile

<h3>ğŸ§± Profile Schema</h3>
const profileSchema = new mongoose.Schema({
  bio: String,
  address: String
});

module.exports = mongoose.model("Profile", profileSchema);


<h3>ğŸ§± User Schema (Reference)</h3>
const userSchema = new mongoose.Schema({
  name: String,
  profile: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Profile"
  }
});


<h2>ğŸ“¥ Save Data</h2>
const profile = await Profile.create({
  bio: "Node Developer",
  address: "India"
});

const user = await User.create({
  name: "Bhavesh",
  profile: profile._id
});


<h3>ğŸ“¤ Fetch with populate()</h3>
User.find().populate("profile");

âœ… Profile data included automatically

<h2>2ï¸âƒ£ ONE-TO-MANY (MOST COMMON)</h2>
Example:
One User â†’ Many Posts

<h3>ğŸ§± Post Schema</h3>
const postSchema = new mongoose.Schema({
  title: String,
  content: String,
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User"
  }
});


<h3>ğŸ“¥ Save Post</h3>
await Post.create({
  title: "MongoDB Basics",
  content: "Learning Mongoose",
  user: userId
});


<h3>ğŸ“¤ Fetch Posts with User</h3>
Post.find().populate("user");

<h2>3ï¸âƒ£ MANY-TO-MANY</h2>
Example:
Students â†” Courses

<h3>ğŸ§± Student Schema</h3>
courses: [{
  type: mongoose.Schema.Types.ObjectId,
  ref: "Course"
}]

<h3>ğŸ§± Course Schema</h3>
students: [{
  type: mongoose.Schema.Types.ObjectId,
  ref: "Student"
}]

<h3>ğŸ“¤ Populate</h3>
Student.find().populate("courses");

<h3>ğŸ” populate() EXPLAINED SIMPLY</h3>
populate("user")

ğŸ‘‰ Takes ObjectId
ğŸ‘‰ Finds matching document
ğŸ‘‰ Replaces ID with full object

<h2>âš ï¸ COMMON MISTAKES</h2>
âŒ Forgetting ref
âŒ Wrong model name
âŒ Using string instead of ObjectId




          
          </pre>
        </li>
      </ul>
      <li><h1>ğŸ”¥ PHASE 6ï¸âƒ£ â€“ REAL WORLD MONGOOSE FEATURES</h1></li>
      <ul>
        <li>
          <pre>
<h2>1ï¸âƒ£ Timestamps (CreatedAt & UpdatedAt)</h2>
Automatically track when data is created/updated.
<h3>âœ… Add to Schema</h3>
const userSchema = new mongoose.Schema(
  {
    name: String,
    email: String
  },
  { timestamps: true }
);

<h3>ğŸ“Œ MongoDB will add:</h3>
createdAt
updatedAt


<h3>2ï¸âƒ£ Indexes (Performance Boost)</h3>
Indexes make search faster.

<h4>Unique Email Index</h4>
email: {
  type: String,
  unique: true
}

<h3>3ï¸âƒ£ Hide Sensitive Data (IMPORTANT)</h3>
âŒ Problem

Password shows in API response.

âœ… Solution
password: {
  type: String,
  select: false
}

Now password wonâ€™t show in find().

<h3>4ï¸âƒ£ Password Hashing (VERY IMPORTANT ğŸ”¥)</h3>
Install bcrypt
npm install bcryptjs

<h2>User Schema</h2>
const bcrypt = require("bcryptjs");

const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  password: String
});


<h3>Hash Before Save (Pre Hook)</h3>
userSchema.pre("save", async function (next) {
  if (!this.isModified("password")) return next();

  this.password = await bcrypt.hash(this.password, 10);
  next();
});

<h3>Compare Password</h3>
userSchema.methods.comparePassword = function (password) {
  return bcrypt.compare(password, this.password);
};

<h2>5ï¸âƒ£ REGISTER API (Real Example)</h2>
app.post("/register", async (req, res) => {
  try {
    const user = await User.create(req.body);
    res.json({ message: "User registered" });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

<h2>6ï¸âƒ£ LOGIN API (VERY IMPORTANT ğŸ”¥)</h2>
app.post("/login", async (req, res) => {
  const { email, password } = req.body;

  const user = await User.findOne({ email }).select("+password");

  if (!user) {
    return res.status(400).json({ message: "User not found" });
  }

  const isMatch = await user.comparePassword(password);

  if (!isMatch) {
    return res.status(400).json({ message: "Wrong password" });
  }

  res.json({ message: "Login successful" });
});


<h2>7ï¸âƒ£ Environment Variables (SECURITY)</h2>
<h3>Install dotenv</h3>
npm install dotenv

<h4>.env</h4>
MONGO_URI=mongodb://127.0.0.1:27017/appdb

<h4>Use it</h4>
require("dotenv").config();

mongoose.connect(process.env.MONGO_URI);


<h3>8ï¸âƒ£ Professional Folder Structure</h3>
src/
 â”œâ”€â”€ models/
 â”œâ”€â”€ routes/
 â”œâ”€â”€ controllers/
 â”œâ”€â”€ config/
 â”œâ”€â”€ app.js





        
      </pre>
        </li>
      </ul>
      <li><h1>ğŸ”¥ PHASE 7ï¸âƒ£ â€“ ERROR HANDLING & BEST PRACTICES</h1></li>
      <ul>
        <li>
          <pre>
<h2>1ï¸âƒ£ Why Error Handling Matters?</h2>
Without proper error handling:

App crashes âŒ

Hard to debug âŒ

Bad user experience âŒ

With proper handling:

App never crashes âœ…

Clean responses âœ…

Easy debugging âœ…

<h2>2ï¸âƒ£ Basic tryâ€“catch (Already seen)</h2>
app.get("/users", async (req, res) => {
  try {
    const users = await User.find();
    res.json(users);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

âš ï¸ Works but repetitive.

<h2>3ï¸âƒ£ Central Error Handler (PRO WAY)</h2>
<h3>ğŸ“ middleware/errorHandler.js</h3>
module.exports = (err, req, res, next) => {
  res.status(err.statusCode || 500).json({
    success: false,
    message: err.message || "Server Error"
  });
};


<h2>Use in app.js</h2>
const errorHandler = require("./middleware/errorHandler");

// routes above
app.use(errorHandler);


<h2>4ï¸âƒ£ Custom Error Class (IMPORTANT)</h2>
<h3>ğŸ“ utils/AppError.js</h3>
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
  }
}

module.exports = AppError;

<h2>Usage Example</h2>
if (!user) {
  return next(new AppError("User not found", 404));
}


<h2>5ï¸âƒ£ Async Error Wrapper (NO try-catch everywhere)</h2>
<h3>ğŸ“ utils/catchAsync.js</h3>
module.exports = fn => (req, res, next) => {
  fn(req, res, next).catch(next);
};


<h3>Use It</h3>
app.get("/users", catchAsync(async (req, res) => {
  const users = await User.find();
  res.json(users);
}));

<h2>6ï¸âƒ£ Mongoose Error Handling</h2>
<h3>Duplicate Key Error</h3>

if (err.code === 11000) {
  err.message = "Duplicate field value";
}


<h2>7ï¸âƒ£ Validation Error</h2>
if (err.name === "ValidationError") {
  err.message = Object.values(err.errors)
    .map(e => e.message)
    .join(", ");
}


<h2>8ï¸âƒ£ Best Practices (VERY IMPORTANT)</h2>
âœ… DO

âœ” Use async/await
âœ” Use environment variables
âœ” Central error handling
âœ” Schema validation
âœ” Proper folder structure

âŒ DON'T

âŒ Write logic in routes
âŒ Expose passwords
âŒ Hardcode DB URL
âŒ Ignore errors

<h2>9ï¸âƒ£ Production-Ready Folder Structure</h2>
src/
 â”œâ”€â”€ controllers/
 â”œâ”€â”€ models/
 â”œâ”€â”€ routes/
 â”œâ”€â”€ middleware/
 â”œâ”€â”€ utils/
 â”œâ”€â”€ config/
 â””â”€â”€ app.js


 <h2>ğŸ”Ÿ Interview Questions (YOU MUST KNOW)</h2>

 Q1: What is Mongoose?

ODM for MongoDB providing schema & validation.

Q2: Difference between find & findOne?

find returns array, findOne returns object.

Q3: What is populate?

Used to join referenced documents.

Q4: Why use indexes?

Faster query performance.


        </pre>
        </li>
      </ul>
    </ul>
  </body>
</html>
